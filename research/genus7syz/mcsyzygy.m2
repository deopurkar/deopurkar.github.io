-- The following function computes the embedding of the syzygies in
-- VxSym2V.

-- Input: S = Polynomial ring with n generators = k[V]
---	  I = Ideal in S

-- Satisfying: I is a homogeneous ideal generated by quadrics with
--     linear first syzygies.

-- Output: (M, State), M is a matrix whose rows form a basis for the
--     syzygies in V x Sym2V. S a #cols(M) long list that records the
--     "tensors", i.e. monomials* in V x Sym2V, corresponding to each
--     column.

-- * "monomial" just means an eigen-vector with respect to the torus
--    action.
embedVSym2V = (I, S) -> (
     -- The linear and quadratic forms in the ring
     L1:=flatten entries basis(1,S);
     L2:=flatten entries basis(2,S);
     -- A "monomial" basis of L1 tensor L2
     tensors:={};
     for i from 0 to #L1-1 do (
     	  for j from 0 to #L2-1 do (
	       tensors=append(tensors,{L1_i,L2_j});
	       )
     	  );	    

     R:=res(I);
     -- The (assumed to be quadratic) generators of the ideal
     Q:=flatten entries(R.dd_1);
     -- The syzygies among the generators.
     Syz:=matrix transpose entries(R.dd_2);

     -- "Read" a syzygy S in the quadratic forms G and return the
     -- corresponding coefficient vector with respect to Tensors.
     syzygyVectors := (S,G,Tensors) -> (
     	  T:=new MutableHashTable from apply(Tensors, v-> {v,0});
     	  for i from 0 to #S-1 do (
               for j from 0 to #L1-1 do (
              	    if coefficient(L1_j,S_i)==0 then continue;
              	    for k from 0 to #L2-1 do (
                   	 if coefficient(L2_k,G_i)==0 then continue;
                   	 T#{L1_j,L2_k} = T#{L1_j,L2_k} + coefficient(L1_j,S_i)*coefficient(L2_k,G_i)
                   	 )
              	    );
               );
     	  return apply(Tensors, v -> T#v)
     	  );
     
     -- Read all the syzygies one by one and record them in a matrix
     M := matrix apply(numRows(Syz), i -> syzygyVectors(flatten entries(Syz^{i}),Q,tensors));

     -- We now compute the state tuple and return.
     return (M, apply(numColumns M, i -> tensors_i));
     );

-- The following function computes the embedding of the syzygies in
-- Gamma = ker (V x Sym2V -> Sym3V)

-- Input: S = Polynomial ring with n generators
---	  I = Ideal in S

-- Satisfying: I is a homogeneous ideal generated by quadrics with
--     linear first syzygies.

-- Output: (M, State), M is a matrix whose rows form a basis for the
--     syzygies in Gamma. S is a #cols(M) long list that records the
--     "tensors", i.e. monomials* in Gamma, corresponding to each
--     column. Since I don't know a good way of representing the
--     "monomials" of Gamma, the state will be one of the tensors of
--     VxSym2V that appears in the expression of the element of Gamma
--     in VxSym2V.

-- 	For example: the column that represents the "monomial"
-- 	(eigenvector) {X_0, X_0X_1} - {X_1, X_0^2} will have statie
-- 	either {X_0, X_0X_1} or {X_1, X_0^2}.

-- 	This ambiguity should not cause any issues since, in the end,
-- 	the state vectors of both tensors are the same.

--  * "monomial" just means an eigen-vector with respect to the torus
--     action.
embedGamma = (I, S) -> (
     -- The cubic forms in the ring
     L3:=flatten entries basis(3,S);
     -- We form the matrix of VxSym2V -> Sym3V. The basis of the
     -- source is chosen compatibly with the output of embedVSym2V.
     (M, state):= embedVSym2V(I, S);
     mult := {};
     for i from 0 to numColumns(M)-1 do (
     	  mult = append(mult, 
	       apply(L3, cubic -> coefficient(cubic, (state_i)_0*(state_i)_1)));
     	  );
     Mult := matrix mult;
     -- Check that M indeed factors through the kernel of Mult.
     assert (rank(M*Mult) == 0);     
     K:= generators(ker (transpose Mult));
     MG:= transpose ((transpose M) // K);

     -- Now we must compute the states.
     stateGamma:=(i) -> (
     	  nonZero:=select(numRows K, x ->  K_i_x != 0);
     	  return apply(nonZero, x -> {K_i_x,state_x})         	  	  
     	  );
     return (MG, apply(numColumns MG, stateGamma));
     );

-- The state vector of a given tensor
stateVector = ( s )->(
     v := (s_0)_1;
     sum(exponents(v_0)) + sum(exponents(v_1))
     );	    	 

-- Now we are done with the embedding part. The rest simply concerns
-- the following two pieces of data: (M, s). Here M is a matrix of
-- full rank with more columns than rows, and s is a function from
-- [0..#cols M-1] to n-tuples that gives the state vector
-- corresponding to each column. The goal is to compute enough nonzero
-- maximal minors so that their state vectors surround the barycenter.


-- The following function picks one column out of the given list using
-- the given state vector function. The purpose is to encode the
-- biases that we want (i.e. "I need more columns whose state vectors
-- have large first coordinates.")
pickFavorExtremes = (cols, state) -> (
     ret := cols_(random(#cols));
     if random(4) > 0 then return ret;
     n := #gens S-1;
     favored := select(cols, c -> (state_c)_0 > 0 or (state_c)_n > 0);
     if #favored > 0 then return favored_(random(#favored));
     return ret;
     );

--- The following returns a picker function based on a bias vector
pickBiasVector = (vec) -> (
     pick := (cols, state) -> (
     	  ret := cols_(random(#cols));
--        Ignore the biases with some probability.
--     	  if random(3) > 0 then return ret;
     	  favored := select(cols, c->(sum(apply(state_c,vec, (x,y)->x*y)) > 0));
	  if #favored > 0 then return favored_(random(#favored));
	  return ret;
	  );
     return pick;
     );

-- Gives the column numbers for a random (?!) nonzero maximal minor of
-- M.  Uses the pick function to pick from possible choices of columns
-- at each step.
oneNZMinor = (M, state, pick) -> (
     cols := {};
     --Initially all columns are good
     indepCols := set(0..numColumns M - 1);
     quot := M;
     while #cols < numRows(M) do (
     	  quot = M % M_cols;
     	  for c in toList(indepCols) do (
	       if all(flatten entries quot_c, zero) then indepCols = indepCols - set{c};
	       );     	       	       
     	  cols = append(cols, pick(toList(indepCols), state));
	  );
     assert(det(M_cols) != 0);
     return cols;     	       	  
     );

---  The following code helps with the polymake interface.
printHilbPt = (L) -> ( 
     str:= "1";
     for j from 0 to (numgens S-1) do str = concatenate(str,concatenate(" ",toString lift(L_j,ZZ)));
     return str
     );
     
createPolymakeInputFile = (statePolytopePointsList) -> (
     openOut "temporarypolymakefile.txt";
     polymakeinput :=  concatenate("POINTS",newline);
     for i from 0 to (#statePolytopePointsList - 1) do polymakeinput = concatenate(polymakeinput,concatenate(printHilbPt(statePolytopePointsList_i),newline));
     "temporarypolymakefile.txt" << polymakeinput << closeOut
     );
     
polymakeToM2 = (st) -> (
     p := concatenate("VERTICES",concatenate(newline,"1 "));
     st = replace(p,"{{",st);
     p = concatenate(newline,"1 ");
     st = replace(p,"},{",st);
     st = replace(" ",", ",st);
     st = concatenate(st,"}}");
     return value st
     );

--- The following function ties everything together.

--- Input: M = Full rank matrix with more columns than rows
--       state = Function from [0..#colsM-1] to n-tuples of reals.
--       eachround = How many minors to compute in each attempt.
--       maxrounds = Number of attempts?

-- Tries to compute nonzero maximal minors of M whose state vectors
-- surround the barycenter. 
syzygyMCStable = (M, state, eachround, maxrounds) -> (
     n:=#(state_0);
     states:={};
     r:={};
     minor:={};
     polymakesession:="";
     st:="";
     str:="";
     barycenter:={};
     barycenterstring:="";
     augmentedstatepolytope:="";
     rounds:=0;
     picker:=pickBiasVector(-state_0);
     while rounds <= maxrounds do (
	  for t from 0 to eachround do (
     	       minor = oneNZMinor(M, state, picker);     
	       states = append(states, sum(apply(minor, i->state_i)));
	       );
	  createPolymakeInputFile(states);
	  polymakesession = "!polymake temporarypolymakefile.txt VERTICES";
	  polymakesession << closeOut;
	  st = get polymakesession;
	  str = st;
	  if states == {} then error "states is empty!";
	  if rounds == 0 then (barycenter = (  (sum (states_0)) / (n ));
	       if rounds == 0 then barycenterstring= concatenate("POINTS",concatenate(newline,"1 "));
	       for i from 0 to (n-1) do barycenterstring = concatenate(barycenterstring, concatenate(toString(barycenter)," "));
	       print "barycenter is ";
	       print toString(barycenter) );
	  str = replace("VERTICES",barycenterstring,str);
	  openOut "augmentedtemporarypolymakefile.txt";
	  "augmentedtemporarypolymakefile.txt" << str << closeOut;
	  polymakesession2 = "!polymake augmentedtemporarypolymakefile.txt VERTICES";
	  polymakesession2 << closeOut;
	  augmentedstatepolytope = get polymakesession2;
	  if set polymakeToM2(st) === set polymakeToM2(augmentedstatepolytope)   then return (true, states) else rounds = rounds +1;
     	  -- Change the biases based on the current states.  Try to
     	  -- move away from the current barycenter.
     	  << "New biases: " << apply(sum states, x-> floor(barycenter - x/#states)) << endl;
	  picker = pickBiasVector(apply(sum states, x-> floor(barycenter - x/#states)));
	  );
     if rounds > maxrounds then return (false, states);
     );

-- Just a helper to make sense of the embedding matrices
readState = (states, vec) -> (
     nonzero := select(#vec, x -> not zero vec_x);
     return apply(nonzero, i -> {vec_i, states_i});
     );
     
